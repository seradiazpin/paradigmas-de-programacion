{
  "name": "AspectJ",
  "tagline": "Tutorial de Aspectj",
  "body": "# AspectJ\r\nAspectJ es una extensión de AOP para Java.\r\nFue creado en PARC(Palo Alto Research Center) por el equipo Xerox PARC, liderado por  Gregor Kiczales.\r\nAmpliamente usado como estándar de la POA.\r\nSe caracteriza por su simplicidad y usabilidad.\r\n\r\n## Ventajas\r\n* Facilita/mejora la modularidad de los desarrollos de software.\r\n* El código es organizado y comprimido\r\n* Es reutilizable\r\n* Añade constructores a Java que permiten la implementación modular de crosscutting concerns\r\n* Permite modelar referencias transversales, extiende las capacidades de POO\\\r\n\r\n## Lenguaje\r\n### Aspect\r\nEs la unidad central de Aspectj, se puede colocar en un archivo .aj.\r\nContiene el código que expresa las reglas de los crosscutting.\r\nUn aspecto es una unidad de modularización en AOP como las clases son en OOP.\r\n\r\n```aspectj\r\n    public aspect Aspect {\r\n\t//CODIGO\r\n    }\r\n```\r\n\r\n###PointCut\r\n\r\nUna palabra del lenguaje que selecciona los puntos interesantes (join points) y colecta el contexto de este punto.\r\nSelecciona puntos interesantes de la ejecución.\r\nPueden ser llamadas, ejecuciones, instanciar objetos, constructores, manejo de excepciones.\r\n```aspectj\r\n    pointcut nombreDePunto(): execution(* Clase.metodo(..));\r\n```\r\n#### Tipos de point cuts\r\n![tabla de pointcut](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/puntos1.png)\r\n![tabla de pointcut](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/punto2.png)\r\n\r\n[Mas informacion](https://eclipse.org/aspectj/doc/next/progguide/index.html)\r\n\r\n###Advice\r\nCódigo que se ejecutará cuando se llegue al pointcut este se puede definir de diferentes maneras.\r\nExisten tres tipos de advice: \r\n* before ()\r\n* after ()\r\n* around ()\r\n\r\n#### Before\r\nSe ejecuta  antes de cada join point.\r\n```aspectj\r\n    before() : nombreDePunto(){\r\n        //CODIGO\r\n    }\r\n```\r\n\r\n#### After\r\nSe ejecuta después de cada join point.\r\nPuede de tres tipos:\r\n* returning\r\n* throwing\r\nY el por defecto en el cual se ejecuta sin importar si retorna o lanza una excepción.\r\n```aspectj\r\n    after(): nombreDePunto() {\r\n\t//CODIGO\r\n    }\r\n\r\n    after() returning() : nombreDePunto(){\r\n\t//CODIGO\r\n    }\r\n\r\n    after() throwing() : nombreDePunto() {\r\n\t//CODIGO\r\n    }\r\n```\r\n\r\n#### Around\r\nSe ejecuta en lugar de el join point.\r\nDebe ser declarado con un tipo de retorno.\r\nEl código del join point se puede ejecutar usando la palabra\r\n`proceed();`\r\n\r\n```aspectj\r\n    void around() : nombreDePunto() {\r\n\t//CODIGO\r\n    }\r\n    void around() : nombreDePunto() {\r\n\t//CODIGO\r\n\tproceed();\r\n\t//CODIGO\r\n    }\r\n```\r\n\r\n#### Atributos de los advice\r\n`thisJoinPoint` : Representa el join point en el cual el advice se está ejecutando.\r\n`thisJoinPointStaticPart` : equivalente a `thisJoinPoint.getStaticPart()` pero consume menos recursos.\r\n`thisEnclosingJoinPointStaticPart` : la parte estatica de la dinamica que encierra el join point.\r\n\r\n### Sintaxis de anotaciones\r\n#### Aspect\r\n![aspect](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/aspect.png)\r\n#### PointCut\r\n![pointcut](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/pointcut.png)\r\n#### Advice before\r\n![before](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/before.png)\r\n#### Advice after\r\n![after](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/after.png)\r\n#### Advice around\r\n![aspect](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/around.png)\r\n\r\n### Ejemplos\r\nA continuación veremos un ejemplo en el cual podremos ver la funcionalidad en un ejemplo sencillo.\r\n#### Clase TestAsp\r\nLa clase en la cual tenemos unos cuantos metodos y un main.\r\n```aspectj\r\npublic class TestAsp {\r\n\tpublic void metodo1(int numero){\r\n\t\tSystem.out.println(\"Este es el metodo que recibe un numero, numero->\"+numero);\r\n\t}\r\n\tpublic void metodo1(int numero,String string){\r\n\t\tSystem.out.println(\"Este es el metodo que recibe un numero y una cadena, \"\r\n\t\t\t\t+ \"numero->\"+numero+\", cadena->\"+string);\r\n\t}\r\n\tpublic void metodo2(int numero){\r\n\t\tSystem.out.println(\"Este es el metodo2 que recibe un numero, numero->\"+numero);\r\n\t}\r\n\tpublic void metodo3(){\r\n\t\tSystem.out.println(\"Este es el metodo3 no recibe nada\");\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tTestAsp asp = new TestAsp();\r\n\t\tasp.metodo1(1);\r\n\t\tasp.metodo1(1, \"HOLA\");\r\n\t\tasp.metodo2(1);\r\n\t\t//asp.metodo2(1);\r\n\t\tasp.metodo3();\r\n\t\t\r\n\t\ttry{\r\n\t\t\tSystem.out.println(1/0);\r\n\t\t}catch(Exception e){\r\n\t\t\tSystem.out.println(\"No se puede dividir en 0\");\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n#### Aspect Aspect\r\nNuestro aspecto con algunos puntos de corte para ver su funcion.\r\n```aspectj\r\npublic aspect Aspect {\r\n\t\r\n\tstatic int i = 0;\r\n\tpointcut all() : call(* TestAsp.*(..));\r\n\tpointcut cut_metodo1() : call(* TestAsp.*1(..));\r\n\tpointcut cut_metodo2() : call(* TestAsp.*2(..)) && if(i <= 2);\r\n\tpointcut cut_metodo1_int() : call(* TestAsp.*1(int));\r\n\tpointcut cut_metodo1_IyS() : call(* TestAsp.*1(int,String));\r\n\tpointcut exception(): handler(Exception);\r\n\tpointcut inita(): initialization(TestAsp.new());\r\n\t\r\n\t\r\n\tbefore() : exception(){\r\n\t\tSystem.out.println(\"Alguien dividio por 0!\");\r\n\t};\r\n\tbefore() : inita(){\r\n\t\tSystem.out.println(\"Entrando al constructor \"+thisJoinPoint.getSignature());\r\n\t};\r\n\t\r\n\tafter() : cut_metodo1(){\r\n\t\tSystem.out.println(\"Despues de entrar al metodo 1, x->\"+i);\r\n\t\ti++;\r\n\t}\r\n\tafter() : cut_metodo2(){\r\n\t\tSystem.out.println(\"Despues de entrar al metodo 2, x->\"+i);\r\n\t\ti++;\r\n\t}\r\n\tafter() : cut_metodo1_int(){\r\n\t\tSystem.out.println(\"Despues de entrar al metodo 1, con entero\");\r\n\t}\r\n\tafter() : cut_metodo1_IyS(){\r\n\t\tSystem.out.println(\"Despues de entrar al metodo 1, con entero y string\");\r\n\t}\r\n\tvoid around() : all() {\r\n\t\tSystem.out.println(\"------------------------------------------------\");\r\n\t\tproceed();\r\n\t\tSystem.out.println(\"------------------------------------------------\");\r\n\t}\r\n}\r\n```\r\n##_Expocicion para lenguajes de programacion-_\r\nIntegrantes\r\n* Sergio Alejandro Diaz Pinilla\r\n* Pedro Luis Monroy Garces\r\n* Jefferson Javier Hernández Panqueba\r\n\r\n\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}
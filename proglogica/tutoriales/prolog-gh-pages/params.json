{
  "name": "Prolog",
  "tagline": "",
  "body": "<p align=\"center\">\r\n<img src=\"https://avatars2.githubusercontent.com/u/6884283?v=3&s=200\">\r\n</p>\r\n***\r\n\r\n# 1. Introducción a Prolog \r\nProlog es un lenguaje de programación declarativo que se utiliza para resolver problemas en los que existen objetos y las relaciones entre ellos.  Los lenguajes declarativos se diferencian de los lenguajes imperativos en que están basados en\r\nformalismos abstractos (Prolog tiene sus fundamentos en la lógica de predicados o de primer orden), por lo tanto su semántica no depende de la máquina en la que se ejecutan. Busca obtener conocimiento declarando hechos sobre los objetos y sus relaciones, creando reglas sobre dichos objetos y relaciones y realizando preguntas en ese dominio. Está basado en los siguientes mecanismos básicos: unificación, estructuras de datos basadas en árboles y backtracking.\r\n\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/fig1.png?raw=true\">\r\n</p>\r\n\r\nAntes de comenzar el tutorial es importante  hacer una recomendación. Prolog es diferente a cualquier otro lenguaje de bajo o alto nivel, por tanto, no es recomendable intentar resolver un problema en otro lenguaje para luego traducirlo a Prolog. No hay que buscar un algoritmo que resuelva el problema, sólo es necesario dar las bases para que Prolog lo resuelva.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/06_16_15_MANOSOBRACS5-01.png?raw=true\">\r\n</p>\r\n\r\n\r\n# 2. Sintaxis\r\n\r\n## 2.1 Términos\r\n\r\nLos términos son el único elemento del lenguaje, un término se compone de un **functor** seguido de cero a N **argumentos** entre paréntesis y separados por comas. \r\n\r\n\r\n \r\nEn Lógica de primer orden, los términos se clasifican en tres categorías: constantes, variables y términos compuestos:\r\n- **Constantes**:\r\nEn Prolog se distinguen dos tipos de constantes:\r\n  - *Números*: Este tipo de constantes se utiliza para representar números enteros y números reales, para poder realizar operaciones aritméticas entre ellos.\r\nLos números enteros se expresan con la notación decimal habitual, ejemplo (0,1,-2124,332,etc).\r\nLos números reales se pueden representar con la notación decimal (ejemplo 1.34, -0.345, etc) o también en notación exponencial (por ejemplo 4.3E6, -0.1e+3, 12.03e-2). \r\n  - *Atomos o functores*: Se utilizan para nombrar objetos, propiedades o relaciones. Deben empezar en minúscula (ejemplo luis, pedro, gato, edad, :-, ?-).\r\n\r\n\r\n- **Variables:** Las variables en Prolog se representan mediante cadenas formadas por letras, dígitos y el símbolo\r\nde subrayado, pero es importante que inicien por una letra minúscula o por el símbolo de subrayado _ (ejemplo X, Y, Resultado, _nombre, _).\r\n\r\n- **Estructuras:** Son términos compuestos por otros términos. Se construyen mediante un símbolo de función, denominado\r\n**functor** que se define con un átomo, seguido entre paréntesis, por una conjunto de términos separados por comas, denominados argumentos (Ejemplos: fecha(10,mayo,2011), punto(X,Y), recta(punto(11,21), punto(31,25))).\r\nOJO!: Al escribir una estructura, no puede haber ningún espacio entre el functor y el paréntesis abierto antes de los argumentos. Por ejemplo, *punto (X,Y)* no es una estructura compuesta correcta y generará un error de compilación.\r\n \r\n\r\n## 2.2 Programa\r\nLos programas en Prolog son programas lógicos definidos, y están compuestos por una serie de cláusulas de Horn positivas, es decir, hechos y reglas. \r\n\r\nLa mayoría de los programas Prolog están organizados en cuatro secciones principales:\r\n\r\n- **Dominio**: donde se declaran los argumentos que utilizarán los predicados.\r\n- **Predicados**: donde se declaran todos los predicados no predefinidos que se utilizarán en las siguientes secciones. \r\n- **Objetivos**: esta sección permite ejecutar los programas de forma no interactiva, y por tanto, buscará la solución deseada tan pronto como se ejecute el programa. Como también es habitual usar Prolog de forma interactiva es frecuente ejecutar un programa y luego esperar a que se nos pregunte por los objetivos.\r\n- **Clausulas**: donde se escriben los hechos y las reglas que conocemos del dominio.\r\n\r\n\r\nPara el desarrollo de este tutorial usaremos la herramienta online de Prolog. [swi Prolog](http://swish.swi-prolog.org/)\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/prolog2.png?raw=true\">\r\n</p>\r\n\r\n# 3. Hechos\r\n\r\nUn hecho es una relación entre objetos. Son el tipo de sentencia más sencillo de Prolog y declaran los valores que son verdaderos para un predicado. No tienen que reflejar el mundo real necesariamente, pero será única y exclusivamente lo que Prolog tomará como verdadero. Están conformados por un predicado y un argumento u objetos como se puede observar en la siguiente imagen. \r\n\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/hechos.png?raw=true\">\r\n</p>\r\n\r\nLos hechos pueden construir propiedades o relaciones. Cuando están compuestos por un único argumento (monádicos), se dice que es una propiedad. Cuando se forman con dos o más argumentos (poliádicos), construyen relaciones. Existe una serie de reglas que se deben tener presentes al momento de definir un predicado.\r\n- Los nombres de los hechos (predicado) deben iniciar con minúscula.\r\n- Los argumentos se escriben separados por comas, en minúscula y encerrados entre paréntesis.\r\n- Todos los hechos deben terminar en punto.\r\n\r\nUn ejemplo de un hecho es:\r\n\r\n         persona(juan,27).\r\n\r\n## Ejemplo práctico\r\nPara entender un poco mejor la función de los hechos en Prolog,iniciaremos con un primer ejemplo. Observe el siguiente árbol genealógico. \r\n\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/arbol.png?raw=true\"></p>\r\n\r\nPodemos observar que el tipo de hechos que se presentan en la imagen son relaciones. Tenemos la relación entre dos personas, esta relación podremos llamarla progenitor. Por tanto los hechos que describen el árbol de la imagen quedan definidos como:\r\n\r\n         progenitor(clara,jose).        %Hecho 1\r\n         progenitor(tomas, jose).       %Hecho 2\r\n         progenitor(tomas,isabel).      %Hecho 3\r\n         progenitor(jose, ana).         %Hecho 4\r\n         progenitor(jose, patricia).    %Hecho 5\r\n         progenitor(patricia,jaime).    %Hecho 6\r\n\r\n# 4. Consultas\r\n\r\nSobre un conjunto de hechos se pueden definir realizar una serie de preguntas para extraer conocimiento de la base de datos generada por los hechos. Comienzan con un signo de interrogación seguido de un guión **?-** y terminan en punto.\r\nAnte una consulta, Prolog intenta hacer un *matching* sobre la base de conocimiento. \r\n\r\nLas respuestas a una consulta puede ser **true**, **false** o los elementos que pueden tomar una variable definida. Un ejemplo simple de una consulta puede ser:\r\n\r\n         ?-progenitor(patricia,jaime).\r\n\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/pregunta1.png?raw=true\"></p>\r\n\r\nSe puede observar que la respuesta a la pregunta fue **true**, ya que la consulta pudo ser unificada con el Hecho 6 de la base de conocimiento.\r\n\r\n### Variables\r\n\r\nPara realizar consultas más interesantes se puede hacer el uso de variables. Es importante recordar que las variables deben iniciar con letra mayúscula o con el carácter (**_**). Existe una variable especial, la variable anónima o blanca. Esta variable se utiliza de la misma manera que las demás variables pero nunca toma ningún valor. \r\n\r\n     \r\n## 4.1 Conjunciones de objetivos\r\nSe usan para resolver preguntas complejas que requieren varios hechos. Están compuestas por dos o más objetivos separados por una coma y finalizan en punto. \r\n\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/pregunta2.png?raw=true\"></p>\r\n\r\n## Ejemplo práctico\r\nSiguiendo con el ejemplo del árbol genealógico definido anteriormente, vamos a responder las siguientes preguntas:\r\n- a). ¿Qué arroja la siguiente consulta?: `?-progenitor(jaime,X).` \r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/pregunta4.png?raw=true\"></p>\r\nComo se puede observar la respuesta es **false** ya que no existe en la base de conocimiento un hecho para el cual jaime sea progenitor de alguien. Esto se puede verificar en el árbol genealógico.\r\n\r\n- b). ¿Qué arroja la siguiente consulta?: `?-progenitor(X,jaime).`\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/pregunta5.png?raw=true\"></p>\r\nEsta consulta arroja todos los progenitores de jaime. Según el árbol genealógico de la figura y los hechos definidos para el árbol, la única progenitora de jaime es patricia.\r\n\r\n- c). ¿Qué arroja la siguiente consulta?: `?-progenitor(tomas,X), progenitor(X,Y),progenitor(Y,Z).`\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/pregunta6.png?raw=true\"></p>\r\nArroja la información de los bisnietos de tomas, con su respectivos padres y abuelos. En este caso sólo tenemos una opción para X,Y,Z ya que sólo existe un bisnieto para tomas que es jaime.\r\n\r\n- d). Defina una consulta que permita determinar si clara es bisabuela de jaime.\r\nTeniendo en cuenta la consulta del punto c). podemos usarlo como referencia. Necesitamos construir un árbol con 3 niveles de profundidad,uno para la relación de bisabuelo y abuelo, otro para la relación de abuelo y padre y finalmente el nivel de la relación de padre e hijo. Sabemos que la bisabuela es clara y el bisnieto es jaime, por tanto existen dos variables que no conocemos: el abuelo y el padre. Podemos definir X= abuelo, Y= padre. La consulta quedaría como se muestra a continuación.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/pregunta3.png?raw=true\"></p>\r\nSi clara no fuera bisabuela de jaime, la consulta arrojaría false, pero Prolog logró unificar la consulta con dos hechos:\r\n`?-progenitor(tomas,jose)`, `?-progenitor(jose,patricia).` y `?-progenitor(patricia,jaime).` Por lo tanto X= jose y Y= patricia.\r\n\r\n# 5. Reglas\r\nCuando la verdad de un hecho depende de la verdad de otro hecho o de un grupo de hechos se usa una regla. Declaran las condiciones para que un predicado sea cierto, con una implicación que pueden relacionar hechos para dar los valores de verdad a un predicado (la cabeza se cumple si el cuerpo se cumple). Funcionan como las fórmulas condicionales habituales en lógica. Una regla está compuesta por una cabeza y una cuerpo. El cuerpo puede estar formado por varios hechos y objetivos.\r\nSu sintaxis general es:\r\n\r\n**<p align=\"center\"> cabeza :- objetivo1, objetivo2, ..., objetivon.</p>**\r\n\r\nFormalmente, desde un punto de vista lógico, se interpretaría de la siguiente forma:\r\n*<p align=\"center\"> objetivo1 ∧ ⋯ ∧ objetivon → cabeza</p>*\r\n\r\nLos objetivos van separados por comas, especificando conjunción y al final debe de ir un punto. Por ejemplo:\r\n\r\n                animal_carnívoro( X ):- animal( X ), carnívoro( X ).\r\n\r\nExisten dos tipos de reglas:\r\n- **Conjunciones**\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/conjuncion.png?raw=true\"></p>\r\n\r\n- **Disyunciones**\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/disyuncion.png?raw=true\"></p>\r\n\r\n## 5.1 Reglas recursivas\r\nCon la definición del tipo de reglas simple se pueden resolver diferentes problemas, sin embargo, la gran potencia de Prolog está en la definición de reglas recursivas. Siguiendo con el ejemplo del árbol genealógico,se puede definir relaciones para el abuelo, bisabuelo, tatarabuelo, etc. Podría ser interesante definir la relación predecesor(X,Y). Un predecesor de X podrá ser el progenitor de X. También será predecesor si es abuelo/a, si es tatarabuelo/a, etc., es decir, podríamos definir un conjunto de reglas como:\r\n\r\n         predecesor(X,Y):-progenitor(X,Y).                                   %padre\r\n         predecesor(X,Y):-progenitor(X,Z), progenitor(Z,Y).                  %abuelo\r\n         predecesor(X,Y):-progenitor(X,Z), progenitor(Z,V), progenitor(V,Y). %bisabuelo\r\nResulta engorroso tener que definir una nueva regla para cada vínculo con un predecesor, ¿qué pasaría si queremos conocer a un predecesor 10 niveles atrás en el árbol genealógico?, ¿necesitaremos definir 10 reglas diferentes?. No. Podemos hacer uso de las reglas recursivas.\r\n\r\nPara hacer uso de reglas recursivas se debe considerar 2 casos:\r\n- **Caso básico:** Define cuándo se detiene el cálculo.\r\n- **Caso recursivo:** Suponiendo que ya se ha solucionado un caso más simple, define cómo descomponer el caso actual hasta llegar al caso básico.\r\n\r\nReescribiendo la relación predecesor de forma recursiva quedaría:\r\n\r\n         predecesor(X,Y):-progenitor(X,Y).                    %caso base\r\n         predecesor(X,Y):-progenitor(X,Z), predecesor(Z,Y).   %caso recursivo\r\n\r\n\r\n## Ejemplo práctico.\r\nSiguiendo con el árbol genealógico que hemos venido trabajando, resolver:\r\n\r\n- a). Defina las reglas y consultas para encontrar a la madre y el padre de un elemento o todos los elementos del árbol.\r\nLos padres son progenitores, lo único que cambia entre el padre y la madre es el sexo. Por eso es necesario definir nuevos hechos para representar el sexo de cada persona en el árbol.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/madrepadre.png?raw=true\"></p>\r\nCon la siguiente consulta podemos consultar quién es madre de quién. X= madre, Y=hijo.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/madre.png?raw=true\"></p>\r\nLas filas de la tabla de resultados son las relaciones que se forman según el árbol.\r\n- clara es madre de jose\r\n- patricia es madre de jaime\r\nDe la misma forma podemos consultar los padres y sus hijos en el árbol.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/padre.png?raw=true\"></p>\r\nComo se puede observar en la tabla anterior, se obtie el resultado de todas las parejas que se pueden formar entre padres e hijos según el árbol genealógico.\r\n- tomas es padre de jose\r\n- tomás es padre de isabel\r\n- jose es padre de ana\r\n- jose es padre de patricia\r\n\r\n- b). Defina las reglas y consultas para encontrar un abuelo.\r\nSabemos que un abuelo tiene dos niveles de relación con un nieto: `progenitor(Abuelo,Padre).` y `progenitor(Padre,Nieto).`\r\nPor tanto podemos definir la siguiente relación:\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/abuelo.png?raw=true\"></p>\r\n\r\n- c). Defina las reglas y consultas para encontrar los antepasados usando reglas recursivas.\r\nPara determinar un antepasado de forma recursiva necesitamos dos casos: El caso base y el caso recursivo. Por tanto la regla queda definida de la siguiente forma:\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/antepasado.png?raw=true\"></p>\r\n\r\n\r\n# 6.  Backtracking\r\nConsiderando el siguiente ejemplo, vamos a entender cómo hace Prolog para verificar cuándo se cumple una regla.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/recursiva.png?raw=true\"></p>\r\nProlog intenta satisfacer los objetivos de la consulta de izquierda a derecha y para\r\ncada uno va probando las cláusulas correspondientes.\r\n\r\n### Primer intento\r\nProlog trabaja analizando los objetivos de izquierda a derecha los objetivos de la regla. Y verificando los hechos de arriba hacia abajo.\r\nEl primer objetivo que intentará analizar es `sevende(Y).`\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/arbol1.png?raw=true\"></p>\r\n\r\nComo el orden en que se definan los hechos importa, el primer hecho que encuentra en la base de conocimiento es `sevende(vestido).` Así que la variable Y queda instanciada como vestido.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/arbol2.png?raw=true\"></p>\r\n\r\nAhora debe verificar para cuales hechos se cumple que `gusta(X,vestido).`\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/arbol3.png?raw=true\"></p>\r\n\r\nComo se puede observar en la imagen, la X queda instanciada como maria porque es el primer hecho para el cual se cumple el objetivo.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/arbol4.png?raw=true\"></p>\r\n\r\nFinalmente debe verificar el último objetivo `bueno(vestido).`. Este objetivo no está definido en la base de conocimiento por tanto este camino en el árbol se rechaza porque ha seleccionado una cláusula que no conduce a la solución. Por esta razón es necesario aplicar un retroceso **backtracking**.\r\n\r\n### Segundo intento\r\nProlog se devuelve hasta el punto donde instanció Y= vestido. Y busca el siguiente hecho que pueda unificar con  `sevende(X).` obteniendo como resultado X= sombrero. Se repiten los demás pasos, llegando finalmente al hecho `sevende(sombrero).` como una verdad, por tanto el camino se acepta obteniendo una posibilidad a la regla con Y= sombrero y X= maria.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/arbol5.png?raw=true\"></p>\r\n\r\n\r\n\r\n# 7. Expresiones\r\n## 7.1 Construcción de expresiones aritméticas\r\nProlog tiene predefinidos los operadores aritméticos más habituales, mediante los que se pueden formar expresiones aritméticas. A continuación se enumeran algunos de los más importantes:\r\n\r\nExpresión | Operación\r\n------------ | -------------\r\nX+Y | suma de X e Y\r\nX-Y | X menos Y\r\nX*Y | producto de X por Y\r\nX/Y | cociente real de la división de X por Y\r\nX//Y | cociente entero de la división de X por Y\r\nX mod Y | resto de la división entera de X por Y\r\nabs(X) | valor absoluto de X\r\nabs(X) | valor absoluto de X \r\nacos(X) | arco coseno de X\r\nasen(X) | arco seno de X\r\natan(X) | arco tangente de X\r\ncos(X) | coseno de X\r\nexp(X) | exponencial de X; [eX]\r\nln(X) | logaritmo neperiano de X\r\nlog(X) | logaritmo en base 2 de X\r\nsin(X) | seno de X\r\nsqrt(X) | raíz cuadrada de X\r\ntan(X) | tangente de X\r\nround(X,N) | redondeo del real X con N decimales\r\n\r\nEs importante tener en cuenta que los operadores anteriores sólo permiten construir expresiones aritméticas, pero estas  son estructuras (términos compuestos) que no representan ningún valor. Por ejemplo, la expresión 13+5 no es otra cosa  que el término compuesto +(3,5) escrito en *notación infija*. No se pueden realizar consultas del estilo “ ?- 13+5.”, porque “+” no es un predicado.\r\n¿Qué pasa si hacemos la consulta “ ?- 13+5 = 8.”? \r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/consulta.png?raw=true\"></p>\r\nComo se puede observar a pesar de que al realizar la operación 13+5 obtenemos como resultado 18, para Prolog esto es falso dado que el término compuesto +(3,5) no es unificable con el término constante 8. Para poder evaluar expresiones aritméticas en Prolog hay que utilizar los predicados aritméticos que se describen a continuación.\r\n\r\n## 7.2 Comparación de términos\r\nLos siguientes operadores son los que permiten comparar términos en Prolog.\r\n\r\nExpresión | Operación\r\n------------ | -------------\r\nX<Y | cierto si el valor numérico de X es menor que el de Y\r\nX>Y | cierto si el valor numérico de X es mayor que el de Y\r\nX=<Y | cierto si el valor numérico de X es menor o igual que el de Y\r\nX>=Y | cierto si el valor numérico de X es mayor o igual que el de Y\r\n\r\n\r\n## 7.3 Comparación de expresiones\r\nLos siguientes predicados predefinidos comparan expresiones sin evaluarlas, mediante una comparación sintáctica siguiendo el siguiente orden:\r\n- variables,\r\n- enteros y reales,\r\n- átomos en orden alfabético,\r\n- términos complejos: aridad, nombre y orden según la definición recursiva.\r\n\r\nExpresión | Operación\r\n------------ | -------------\r\nX==Y | la expresión X es igual que la expresión Y\r\nX\\==Y | la expresión X es distinta que la expresión Y\r\nX@<Y | la expresión X es menor que la expresión Y\r\nX@>Y | la expresión X es mayor que la expresión Y\r\nX@=<Y | la expresión X es menor o igual que la expresión Y\r\nX@>=Y | la expresión X es mayor o igual que la expresión Y\r\nX is Y | Si Y es una expresión aritmética, ésta se evalúa y el resultado se intenta unificar con X.\r\n\r\nEjemplo:\r\n\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/aritmetico.png?raw=true\"></p>\r\n         \r\nLos siguientes predicados predefinidos comparan términos haciendo una evaluación\r\nde expresiones:\r\n\r\nExpresión | Operación\r\n------------ | -------------\r\nX =:= Y | cierto si los valores numéricos de X e Y son iguales\r\nX =\\= Y | cierto si los valores numéricos de X e Y son distintos\r\n\r\n\r\n# 8. Predicados predefinidos\r\n\r\nLos predicados predefinidos son aquellos que ya están definidos en PROLOG, es decir, no necesitamos especificarlos mediante cláusulas. Existen dos tipos de predicados predefinidos:\r\n- Aquellos predicados de uso frecuente que ya los proporciona PROLOG, aunque podríamos definirlos nosotros.\r\n- Predicados con un efecto colateral distinto a la instanciación de variables a valores (funcionamiento normal del PROLOG).\r\n\r\nEste conjunto de predicados permiten determinar el tipo de términos que estamos usando.\r\n\r\nPredicado | Función\r\n------------ | -------------\r\nvar | El objetivo var(X) se cumple si X es una variable no instanciada.\r\nnovar | El objetivo novar(X) se cumple si X es una variable instanciada\r\natom | El objetivo atom(X) se cumple si X representa un átomo.\r\ninteger | El objetivo integer(X) se cumple si X representa un número entero.\r\natomic | El objetivo atomic(X) se cumple si X representa un entero o un átomo.\r\n\r\nLos siguientes son predicados predefinidos que permiten controlar otros predicados.\r\n\r\nPredicado | Función\r\n------------ | -------------\r\n!(cut)| Fuerza al sistema a mantener ciertas elecciones que ha realizado.\r\ntrue | Este objetivo siempre se cumple.\r\nfail | Este objetivo siempre fracasa.\r\nnot | El objetivo not(X) se cumple si fracasa el intento de satisfacer X. El objetivo not(X) fracasa si el intento de satisfacer X tiene éxito. Es similar a la negación en la lógica de predicados.\r\nrepeat | forma auxiliar para generar soluciones múltiples mediante el mecanismo de reevaluación.\r\ncall |  Se cumple si tiene éxito el intento de satisfacer X.\r\n; | Especifica una disyunción de objetivos\r\n, | Especifica una conjunción de objetivos\r\n\r\nPredicados de lectura y escritura\r\n\r\nPredicado | Función\r\n------------ | -------------\r\nwrite | escribe el término X en la consola de salida.\r\nnl | genera una nueva línea en la consola de salida.\r\nread | lee el siguiente término en la consola de entrada.\r\ndisplay |  funciona exactamente igual que write, excepto que\r\npasa por alto las declaraciones de operadores\r\n\r\n# 9. Listas\r\nUna lista es una tipo concreto de estructura de datos simple. Es una secuencia ordenada de elementos que puede tener cualquier longitud. Un elemento puede ser cualquier tipo de dato e incluso otra lista.  En Prolog las listas están formadas por cabeza y cola.  Se representan como una serie de elementos separados por comas y encerrados entre corchetes. Por ejemplo en la lista:\r\n   \r\n         [a, b, c, d]\r\nSe tiene que **a** es la cabeza de la lista y [b, c, d] la cola.\r\n \r\nLista | Cabeza | COla\r\n------------ | ------------- | -------------\r\n[a,b,c,d]     |          a         |      [b,c,d] \r\n[a]            |         a          |     [] (lista vacía) \r\n[]              |        no tiene    |    no tiene \r\n[[a,b],c]        |       [a,b]        |   [c] \r\n[a,[b,c]]         |      a             |  [[b,c]] \r\n[a,b,[c,d]]        |     a              | [b,[c,d]]\r\n\r\nUna lista cuya cabeza es A y la cola es B, en prolog se denota como:\r\n\r\n         [A | B]\r\n\r\n## 9.1 Unificación y listas\r\nEn Prolog se puede unificar una lista con otra.\r\n\r\n         [X,Y,Z]= [a,b,c]\r\n         X = a\r\n         Y = b\r\n         Z = c\r\n\r\nUna variable que no está instanciada se puede unificar con cualquier objeto, por tanto se puede unificar una lista con una variable.\r\n\r\n         X= [a,b,c]\r\n\r\nPara unificar una variable con una lista pero separando su cabeza y cola se debe hacer de la forma  [A | B] donde el símbolo (|) separará la cabeza de la cola. Ejemplo:\r\n\r\n         [a,b,c] = [Cabeza|Cola]\r\n         Cabeza = a\r\n         Cola = [b,c]\r\n\r\n\r\n         [a,b,c] = [X,Y|Z]\r\n         X = a\r\n         Y = b\r\n         Z = [c] \r\n\r\n         [a,b,c] = [X,Y,Z|Cola] \r\n         X = a\r\n         Y = b\r\n         Z = c\r\n         Cola = [ ] \r\n\r\n## 9.2 Listas y recursión\r\n\r\nEn Prolog existen tres criterios de terminación importantes:\r\n\r\n- Cuando la lista es vacía.\r\nEl esquema general es:\r\n\r\n         /* Regla de terminacion */\r\n         predicado([ ]):- procesar([ ]).\r\n         /* Regla recursiva */\r\n         predicado([Cabeza | Cola]):- procesar(Cabeza), predicado(Cola).\r\n\r\n- Cuando un elemento es encontrado.\r\nEl esquema general es:\r\n\r\n         /* Regla de terminación */\r\n         predicado(Cabeza, [Cabeza | Cola]):- procesar algo.\r\n         /* Regla recursiva */\r\n         predicado(X, [Cabeza | Cola]):- procesar algo, predicado(X, Cola).\r\n\r\n- Cuando una posición es encontrada.\r\nEl esquema general es:\r\n\r\n         /* Regla de terminacion */\r\n         predicado(1,Cabeza, [Cabeza | Cola]):- procesar algo.\r\n         /* Regla recursiva */\r\n         predicado(P, X, [ | L]):- P1=P-1, predicado(P1,X, L).\r\n\r\n### Ejemplos prácticos:\r\n- a). Encontrar el último elemento de una lista.\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/lista1.png?raw=true\">\r\n\r\n- b). Encontrar el k-ésimo elemento de una lista.\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/lista2.png?raw=true\">\r\n\r\n- c). Calcular la longitud de la lista.\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/lista4.png?raw=true\">\r\n\r\n- d). Verifica si una lista es palíndroma o no.\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/lista5.png?raw=true\">\r\n\r\n- e). Crear una lista que contenga los enteros de un rango dado.\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/lista6.png?raw=true\">\r\n\r\n- f). Sumar los elementos de una lista\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/lista7.png?raw=true\">\r\n\r\n# 10. Arboles\r\nUn árbol binario es una estructura que contiene un nodo padre y dos nodos hijos; uno izquierdo y uno derecho. Se puede decir que un árbol es una estructura con una definición puramente recursiva, ya que se puede definir como el elemento raíz cuyos hijos son a su vez árboles. \r\n\r\n#### Representación en Prolog de árboles \r\nComo un árbol es una estructura recursiva, necesitaremos un caso base y un caso recursivo. \r\n- X es un árbol vacío\r\n- X es un árbol con hijos\r\n\r\n         binary_tree(void).                       %caso base\r\n         binary_tree(t(K,L,R)) :-                 %caso recursivo\r\n                                 binary_tree(L), \r\n                                 binary_tree(R).\r\n\r\nComo se puede observar se necesitan 3 elementos para definir un árbol: la raíz, el subárbol izquierdo y el subárbol derecho. Veamos un ejemplo:\r\n\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/tree1.png?raw=true\"></p>\r\n\r\nEl árbol de la imagen en la relación t(K,L,R) queda definido como:\r\n\r\n         tree1(t(6, t(4, t(2, nil, nil), t(5, nil, nil)), t(9, t(7, nil, nil), nil))).\r\n\r\n\r\nTambién podemos definir reglas para realizar los posibles recorridos en el árbol:\r\n\r\n- **Inorder:**\r\n         \r\n         inorder(nil, []).\r\n         inorder(t(K,L,R), List):-inorder(L,LL), \r\n                                  inorder(R, LR),\r\n                                  append(LL, [K|LR],List).\r\n         \r\n- **Preorder:**\r\n\r\n         preorder(nil, []). \r\n         preorder(t(K,L,R), List):-preorder(L,LL),\r\n                                   preorder(R, LR),\r\n                                   append([K|LL], LR, List).\r\n\r\n- **Postorder:**\r\n\r\n         postorder(nil, []). \r\n         postorder(t(K,L,R), List):-postorder(L,LL), \r\n                                    postorder(R, LR),\r\n                                    append(LL, LR,R1), \r\n                                    append(R1, [K], List).\r\n\r\nAl realizar las pruebas con el árbol del ejemplo y los diferentes recorridos obtenemos como resultado:\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/arbolrecorrido.png?raw=true\"></p>\r\n\r\n# 11. Ejemplo Grafos\r\nImplementar el siguiente grafo en Prolog y definir una regla para encontrar los caminos de un nodo.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/grafo.png?raw=true\"></p>\r\n\r\nTodas las uniones entre dos nodos pueden ser representadas como hechos de relaciones, por tanto quedaría definido como:\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/grafo1.png?raw=true\"></p>\r\n\r\n# 12. Ejemplo Autómatas\r\nImplementar un AFD en prolog que acepte el lenguaje determinado por el siguiente autómata:\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/automata.png?raw=true\"></p>\r\n\r\nUn autómata puede verse como un grafo dirigido con un estado de inicio y otro de finalización. Podemos representar la unión entre estados como un hecho de relación y es importante hacer la definición del estado inicial y el estado final. El autómata quedaría definido como:\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/automata1.png?raw=true\"></p>\r\n \r\nVamos a verificar la anterior definición con una cadena que sí sea aceptada por el autómata. En este caso probaremos para la cadena **[b,b,a,a,b,a,b]**, verificando que es una cadena aceptada.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/automata2.png?raw=true\"></p>\r\n\r\nFinalmente realizaremos la prueba con la cadena **[b,b,a]**, la cual debería ser rechazada.\r\n<p align=\"center\">\r\n<img src=\"https://github.com/mppinedav/prologtutorial/blob/master/automata3.png?raw=true\"></p>\r\n\r\n\r\n---\r\nEsperamos que el tutorial haya sido de su agrado. Todos los ejercicios trabajados pueden encontrarlos en este [notebook](http://swish.swi-prolog.org/p/tutorialprolog.swinb)\r\n---\r\nEste tutorial fue desarrollado por Mónica Pineda, Jorge Bonilla y Diego Poveda.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}
{
  "name": "AspectJ",
  "tagline": "Tutorial de Aspectj",
  "body": "# AspectJ\r\nAspectJ es una extensión de AOP para Java.\r\nFue creado en PARC(Palo Alto Research Center) por el equipo Xerox PARC, liderado por  Gregor Kiczales.\r\nAmpliamente usado como estándar de la POA.\r\nSe caracteriza por su simplicidad y usabilidad.\r\n\r\n## Ventajas\r\n* Facilita/mejora la modularidad de los desarrollos de software.\r\n* El código es organizado y comprimido\r\n* Es reutilizable\r\n* Añade constructores a Java que permiten la implementación modular de crosscutting concerns\r\n* Permite modelar referencias transversales, extiende las capacidades de POO\\\r\n\r\n## Lenguaje\r\n### Aspect\r\nEs la unidad central de Aspectj, se puede colocar en un archivo .aj.\r\nContiene el código que expresa las reglas de los crosscutting.\r\nUn aspecto es una unidad de modularización en AOP como las clases son en OOP.\r\n\r\n```aspectj\r\n    public aspect Aspect {\r\n\t//CODIGO\r\n    }\r\n```\r\n\r\n###PointCut\r\n\r\nUna palabra del lenguaje que selecciona los puntos interesantes (join points) y colecta el contexto de este punto.\r\nSelecciona puntos interesantes de la ejecución.\r\nPueden ser llamadas, ejecuciones, instanciar objetos, constructores, manejo de excepciones.\r\n```aspectj\r\n    pointcut nombreDePunto(): execution(* Clase.metodo(..));\r\n```\r\n#### Tipos de point cuts\r\n![tabla de pointcut](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/puntos1.png)\r\n![tabla de pointcut](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/punto2.png)\r\n\r\n[Mas informacion](https://eclipse.org/aspectj/doc/next/progguide/index.html)\r\n\r\n###Advice\r\nCódigo que se ejecutará cuando se llegue al pointcut este se puede definir de diferentes maneras.\r\nExisten tres tipos de advice: \r\n* before ()\r\n* after ()\r\n* around ()\r\n\r\n#### Before\r\nSe ejecuta  antes de cada join point.\r\n```aspectj\r\n    before() : nombreDePunto(){\r\n        //CODIGO\r\n    }\r\n```\r\n\r\n#### After\r\nSe ejecuta después de cada join point.\r\nPuede de tres tipos:\r\n* returning\r\n* throwing\r\nY el por defecto en el cual se ejecuta sin importar si retorna o lanza una excepción.\r\n```aspectj\r\n    after(): nombreDePunto() {\r\n\t//CODIGO\r\n    }\r\n\r\n    after() returning() : nombreDePunto(){\r\n\t//CODIGO\r\n    }\r\n\r\n    after() throwing() : nombreDePunto() {\r\n\t//CODIGO\r\n    }\r\n```\r\n\r\n#### Around\r\nSe ejecuta en lugar de el join point.\r\nDebe ser declarado con un tipo de retorno.\r\nEl código del join point se puede ejecutar usando la palabra\r\n`proceed();`\r\n\r\n```aspectj\r\n    void around() : nombreDePunto() {\r\n\t//CODIGO\r\n    }\r\n    void around() : nombreDePunto() {\r\n\t//CODIGO\r\n\tproceed();\r\n\t//CODIGO\r\n    }\r\n```\r\n\r\n#### Atributos de los advice\r\n`thisJoinPoint` : Representa el join point en el cual el advice se está ejecutando.\r\n`thisJoinPointStaticPart` : equivalente a `thisJoinPoint.getStaticPart()` pero consume menos recursos.\r\n`thisEnclosingJoinPointStaticPart` : la parte estatica de la dinamica que encierra el join point.\r\n\r\n### Sintaxis de anotaciones\r\n#### Aspect\r\n![aspect](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/aspect.png)\r\n#### PointCut\r\n![pointcut](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/pointcut.png)\r\n#### Advice before\r\n![before](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/before.png)\r\n#### Advice after\r\n![after](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/after.png)\r\n#### Advice around\r\n![aspect](https://raw.githubusercontent.com/seradiazpin/paradigmas-de-programacion/master/poa/tutorial/images/around.png)\r\n\r\n### Ejemplos\r\nA continuación veremos un ejemplo en el cual podremos ver la funcionalidad en un ejemplo sencillo.\r\n#### Clase TestAsp\r\nLa clase en la cual tenemos unos cuantos metodos y un main.\r\n```aspectj\r\npublic class TestAsp {\r\n\tpublic void metodo1(int numero){\r\n\t\tSystem.out.println(\"Este es el metodo que recibe un numero, numero->\"+numero);\r\n\t}\r\n\tpublic void metodo1(int numero,String string){\r\n\t\tSystem.out.println(\"Este es el metodo que recibe un numero y una cadena, \"\r\n\t\t\t\t+ \"numero->\"+numero+\", cadena->\"+string);\r\n\t}\r\n\tpublic void metodo2(int numero){\r\n\t\tSystem.out.println(\"Este es el metodo2 que recibe un numero, numero->\"+numero);\r\n\t}\r\n\tpublic void metodo3(){\r\n\t\tSystem.out.println(\"Este es el metodo3 no recibe nada\");\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tTestAsp asp = new TestAsp();\r\n\t\tasp.metodo1(1);\r\n\t\tasp.metodo1(1, \"HOLA\");\r\n\t\tasp.metodo2(1);\r\n\t\t//asp.metodo2(1);\r\n\t\tasp.metodo3();\r\n\t\t\r\n\t\ttry{\r\n\t\t\tSystem.out.println(1/0);\r\n\t\t}catch(Exception e){\r\n\t\t\tSystem.out.println(\"No se puede dividir en 0\");\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n#### Aspect Aspect\r\nNuestro aspecto con algunos puntos de corte para ver su funcion.\r\n```aspectj\r\npublic aspect Aspect {\r\n\t\r\n\tstatic int i = 0;\r\n\tpointcut all() : call(* TestAsp.*(..));\r\n\tpointcut cut_metodo1() : call(* TestAsp.*1(..));\r\n\tpointcut cut_metodo2() : call(* TestAsp.*2(..)) && if(i <= 2);\r\n\tpointcut cut_metodo1_int() : call(* TestAsp.*1(int));\r\n\tpointcut cut_metodo1_IyS() : call(* TestAsp.*1(int,String));\r\n\tpointcut exception(): handler(Exception);\r\n\tpointcut inita(): initialization(TestAsp.new());\r\n\t\r\n\t\r\n\tbefore() : exception(){\r\n\t\tSystem.out.println(\"Alguien dividio por 0!\");\r\n\t};\r\n\tbefore() : inita(){\r\n\t\tSystem.out.println(\"Entrando al constructor \"+thisJoinPoint.getSignature());\r\n\t};\r\n\t\r\n\tafter() : cut_metodo1(){\r\n\t\tSystem.out.println(\"Despues de entrar al metodo 1, x->\"+i);\r\n\t\ti++;\r\n\t}\r\n\tafter() : cut_metodo2(){\r\n\t\tSystem.out.println(\"Despues de entrar al metodo 2, x->\"+i);\r\n\t\ti++;\r\n\t}\r\n\tafter() : cut_metodo1_int(){\r\n\t\tSystem.out.println(\"Despues de entrar al metodo 1, con entero\");\r\n\t}\r\n\tafter() : cut_metodo1_IyS(){\r\n\t\tSystem.out.println(\"Despues de entrar al metodo 1, con entero y string\");\r\n\t}\r\n\tvoid around() : all() {\r\n\t\tSystem.out.println(\"------------------------------------------------\");\r\n\t\tproceed();\r\n\t\tSystem.out.println(\"------------------------------------------------\");\r\n\t}\r\n}\r\n```\r\n\r\n## TUTORIAL\r\nA partir de una aplicación de un banco se desea implementar un Log de transacciones y un sistema de login mediante programación orientada a aspectos.\r\nPara esto se tienen las siguientes clases en las cuales se implementa la funcionalidad sencilla de un banco.\r\n```java\r\npublic class Bank {\r\n\t\r\n\tstatic ArrayList<User> users = new ArrayList<>();\r\n\tprivate static Scanner input = new Scanner(System.in);\r\n\tpublic static void initBank(){\r\n\t\tusers.add(new User(1,\"Usuario1\",1,0.0));\r\n\t\tusers.add(new User(2,\"Usuario2\",2,10000.0));\r\n\t\tusers.add(new User(3,\"Usuario3\",3,1000000.0));\r\n\t\tusers.add(new User(4,\"Usuario4\",4,500.0));\r\n\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tint opcion = 0;\r\n\t\tinitBank();\r\n\t\twhile(opcion != 5){\r\n\t\t\topcion = menu();\r\n\t\t};\r\n\r\n\t}\r\n\tpublic static int menu(){\r\n\t\tSystem.out.println(\"Banco AspectJ\");\r\n\t\tSystem.out.println(\"------------------------------------\");\r\n\t\tSystem.out.println(\"1 - Crear Usuario\");\r\n\t\tSystem.out.println(\"2 - Hacer Transaccion\");\r\n\t\tSystem.out.println(\"3 - Retirar dinero\");\r\n\t\tSystem.out.println(\"4 - Ver usuarions\");\r\n\t\tSystem.out.println(\"5 - Salir\");\r\n\t\tSystem.out.println(\"------------------------------------\");\r\n\t\tint option = Integer.valueOf(readConsole(\"Opcion\"));\r\n\t\tswitch (option) {\r\n\t\tcase 1:\r\n\t\t\tSystem.out.println(\"CREAR USUARIO\");\r\n\t\t\tSystem.out.println(\"------------------------------------\");\r\n\t\t\tcreateUser();\r\n\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tSystem.out.println(\"Hacer transaccion\");\r\n\t\t\tSystem.out.println(\"------------------------------------\");\r\n\t\t\t makeTransaction();\t\r\n\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tSystem.out.println(\"Retirar dinerro\");\r\n\t\t\tSystem.out.println(\"------------------------------------\");\r\n\t\t\t myMoney();\r\n\t\tbreak;\r\n\t\tcase 4:\r\n\t\t\tSystem.out.println(\"Ver Usuarios\");\r\n\t\t\tviewUsers();\r\n\t\tbreak;\r\n\t\tcase 5:\r\n\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tSystem.out.println(\"Opcion incorrecta\");\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn option;\r\n\t}\r\n\t\r\n\tpublic static  String readConsole(String mensaje){\r\n\t\tSystem.out.println(mensaje);  \r\n\t\tString inputText;\r\n\t\tinputText = input.nextLine();           \r\n\t\treturn inputText;\r\n\t}\r\n\t\r\n\tpublic static void createUser(){\r\n\t\tString nombre = readConsole(\"Nombre :\");\r\n\t\tint id = Integer.valueOf(readConsole(\"Id: \"));\r\n\t\tdouble money = Double.valueOf(readConsole(\"Dinero: \"));\r\n\t\tusers.add(new User(users.size(),nombre,id,money));\r\n\t}\r\n\t\r\n\tpublic static void makeTransaction(){\r\n\t\tint id = Integer.valueOf(readConsole(\"Key: \"));\r\n\t\tdouble money = Double.valueOf(readConsole(\"Dinero a consignar: \"));\r\n\t\tusers.get(id-1).setMoney(users.get(id-1).getMoney() + money);\r\n\t}\r\n\tpublic static void myMoney(){\r\n\t\tint id = Integer.valueOf(readConsole(\"Key: \"));\r\n\t\tdouble money = Double.valueOf(readConsole(\"Dinero a consignar: \"));\r\n\t\tusers.get(id-1).setMoney(users.get(id-1).getMoney() - money);\r\n\t}\r\n\tpublic static void viewUsers(){\r\n\t\tSystem.out.println(\"------------------------------------\");\r\n\t\tfor(User u:users){\t\r\n\t\t\tSystem.out.println(u);\r\n\t\t}\r\n\t\tSystem.out.println(\"------------------------------------\");\r\n\t}\r\n\t\r\n\r\n}\r\n```\r\nAdicionalmente se tiene la siguiente clase la cual representa a los usuarios de este banco.\r\n```java\r\npackage BankLogic;\r\n\r\npublic class User {\r\n\tprivate int key;\r\n\tprivate String name;\r\n\tprivate int id;\r\n\tprivate double money;\r\n\t\r\n\t\r\n\tpublic User(int key, String name, int id, double money){\r\n\t\tthis.key = key;\r\n\t\tthis.name = name;\r\n\t\tthis.id = id;\r\n\t\tthis.money = money;\r\n\t}\r\n\tpublic int getKey() {\r\n\t\treturn key;\r\n\t}\r\n\tpublic void setKey(int key) {\r\n\t\tthis.key = key;\r\n\t}\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\tpublic int getId() {\r\n\t\treturn id;\r\n\t}\r\n\tpublic void setId(int id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\tpublic double getMoney() {\r\n\t\treturn money;\r\n\t}\r\n\tpublic void setMoney(double money) {\r\n\t\tthis.money = money;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"User [key=\"+key+\", name=\" + name + \", id=\" + id + \", money=\" + money + \"]\";\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\t\r\n}\r\n```\r\n###Aspectos\r\nSe implementaran dos aspectos uno llamado `Login` y otro llamado `Log`.\r\n```aspectj\r\npublic aspect Login {\r\n\r\n}\r\n\r\n```\r\n```aspectj\r\npublic aspect Log {\r\n\r\n}\r\n```\r\nAhora devemos identificar los join points de nuestra aplicacion para poder iplementar los Pointcuts en los aspectos.\r\n### Identificacion de los puntos de corte de los aspectos\r\n```java\r\n\tpublic static void makeTransaction(){\r\n\t\tint id = Integer.valueOf(readConsole(\"Key: \"));\r\n\t\tdouble money = Double.valueOf(readConsole(\"Dinero a consignar: \"));\r\n\t\tusers.get(id-1).setMoney(users.get(id-1).getMoney() + money);\r\n\t}\r\n\tpublic static void myMoney(){\r\n\t\tint id = Integer.valueOf(readConsole(\"Key: \"));\r\n\t\tdouble money = Double.valueOf(readConsole(\"Dinero a consignar: \"));\r\n\t\tusers.get(id-1).setMoney(users.get(id-1).getMoney() - money);\r\n\t}\r\n```\r\nEsta es la funcionalidad que queremos guardar en el log de transacciones.\r\n```java\r\n       public static void makeTransaction(){\r\n\t\tint id = Integer.valueOf(readConsole(\"Key: \"));\r\n\t\tdouble money = Double.valueOf(readConsole(\"Dinero a consignar: \"));\r\n\t\tusers.get(id-1).setMoney(users.get(id-1).getMoney() + money);\r\n\t}\r\n\tpublic static void myMoney(){\r\n\t\tint id = Integer.valueOf(readConsole(\"Key: \"));\r\n\t\tdouble money = Double.valueOf(readConsole(\"Dinero a consignar: \"));\r\n\t\tusers.get(id-1).setMoney(users.get(id-1).getMoney() - money);\r\n\t}\r\n        public static void createUser(){\r\n\t\tString nombre = readConsole(\"Nombre :\");\r\n\t\tint id = Integer.valueOf(readConsole(\"Id: \"));\r\n\t\tdouble money = Double.valueOf(readConsole(\"Dinero: \"));\r\n\t\tusers.add(new User(users.size(),nombre,id,money));\r\n\t}\r\n```\r\nEsta es la funcionalidad que queremos aplicarle un login.\r\nAunque hay join point que son comunes por buena practica los viviremos en dos aspectos.\r\n```aspectj\r\npublic aspect Log {\r\n\tpointcut logActions():execution(void Bank.make*(..))\r\n\t\t\t\t\t\t||execution(void Bank.my*(..));\r\n\t\r\n}\r\n```\r\nEn el primer punto de corte queremos capturar los metodos que comiensen con make y my.\r\n```aspectj\r\npublic aspect Login {\r\n\tpublic aspect Log {\r\n\t\tpointcut transaction():execution(void Bank.make*(..));\r\n\t        pointcut money():execution(void Bank.my*(..));\r\n\t        pointcut user():execution(void Bank.create*(..));\r\n\t}\r\n}\r\n```\r\nQueremos capturar las distintos tipos de transacciones.\r\nPosteriormente agregamos los advices que queremos en los dos aspectos con su funcionalidad correspondiente.\r\n```aspectj\r\npublic aspect Log {\r\n\tFile file = new File(\"log.txt\");\r\n\tCalendar cal = Calendar.getInstance();\r\n\tpointcut transaction():execution(void Bank.make*(..));\r\n\tpointcut money():execution(void Bank.my*(..));\r\n\tpointcut user():execution(void Bank.create*(..));\r\n\t\r\n\tafter() : transaction(){\r\n\t\twriteFile(\"Transaccion realisada \"+cal.getTime());\r\n\t}\r\n\tafter() : money(){\r\n\t\twriteFile(\"Dinero retirado \"+cal.getTime());\r\n\t\t}\r\n\tafter() : user(){\r\n\t\twriteFile(\"Usuario creado \"+cal.getTime());\r\n\t}\r\n\t\r\n\tpublic void writeFile(String mensaje){\r\n\t\ttry {\r\n\r\n\t\t\tString content = mensaje;\r\n\r\n\t\t\t\r\n\r\n\t\t\t// if file doesnt exists, then create it\r\n\t\t\tif (!file.exists()) {\r\n\t\t\t\tfile.createNewFile();\r\n\t\t\t}\r\n\r\n\t\t\tFileWriter fw = new FileWriter(file.getAbsoluteFile());\r\n\t\t\tBufferedWriter bw = new BufferedWriter(fw);\r\n\t\t\tbw.write(content);\r\n\t\t\tbw.close();\r\n\r\n\t\t\tSystem.out.println(\"Done\");\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\nQueremos que escribir el los se realice depues de que la transacción se haya realizado, por esta razón elegimos after.\r\n```aspectj\r\npublic aspect Login {\r\n\t\tprivate static Scanner input = new Scanner(System.in);\r\n\t\tpointcut needLogin():execution(void Bank.make*(..))\r\n\t\t\t\t\t\t\t||execution(void Bank.my*(..));\r\n\t\t\r\n\t\tbefore():needLogin(){\r\n\t\t\tSystem.out.println(\"Es necesario logiarce\");\r\n\t\t\treadConsole(\"Nombre: \");\r\n\t\t\treadConsole(\"Id: \");\r\n\t\t}\r\n\t\t\r\n\t\tpublic static  String readConsole(String mensaje){\r\n\t\t\tSystem.out.println(mensaje);  \r\n\t\t\tString inputText;\r\n\t\t\tinputText = input.nextLine();           \r\n\t\t\treturn inputText;\r\n\t\t}\r\n\t\r\n}\r\n```\r\nQueremos que el login sea antes de la transacción se haya realizado, por esta razón elegimos before.\r\nEste es un ejemplo muy sencillo de lo que nos permite aspectj.\r\n\r\nFinalmente este código nos agrega la funcionalidad de un login antes de las transacciones y un registro de sus actividades en un archivo.\r\n\r\n[Mas ejemplos](https://github.com/JeffersonH44/AspectJExamples)\r\n##_Expocicion para lenguajes de programacion-_\r\nIntegrantes\r\n* Sergio Alejandro Diaz Pinilla\r\n* Pedro Luis Monroy Garces\r\n* Jefferson Javier Hernández Panqueba\r\n\r\n\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}